# 知识总结

- scoped:带有作用域的样式,防止样式冲突
  - 例如:.avatar-img[data-v-5811d9ee](唯一标识)
- display: block; 行盒：与其他行盒在同一行排列

### 预编译

| **维度**     | **Vue 模板预编译**                                                            | **Vite 依赖预编译**                                                                                             |
| ------------ | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **技术范畴** | Vue 框架的**生产环境构建优化**，解决模板运行时编译开销问题。                  | Vite 构建工具的**开发环境体验优化**，解决第三方依赖加载效率与兼容性问题。                                       |
| **目标**     | 让 Vue 项目在生产环境**运行更快、体积更小**。                                 | 让项目在开发环境**启动更快、请求更少**，提升开发体验。                                                          |
| **发生阶段** | 项目**构建阶段**（如 `vue-cli` 打包时）。                                     | 开发环境**启动阶段**（运行 `vite` 命令后）。                                                                    |
| **处理对象** | Vue 组件的 `<template>` 模板 → 转换为 `render` 函数。                         | 第三方依赖模块（如 `lodash`、`react` 等）→ 转换模块格式、合并小模块。                                           |
| **依赖工具** | `vue-loader`、`@vue/compiler-sfc` 等 Vue 生态工具。                           | `esbuild`（Go 语言编写的极速构建工具）。                                                                        |
| **核心作用** | 1. 运行时无需编译模板，提升渲染性能；2. 移除 Vue 运行时编译器，减小打包体积。 | 1. 转换 CommonJS 依赖为 ES 模块，兼容浏览器；2. 合并小模块，减少浏览器请求数；3. 缓存预编译结果，加速后续启动。 |

### 计算属性和方法的区别

- 计算属性**本质上是包含 getter 和 setter**的方法
  - 当获取计算属性时，实际正是在调用计算属性的 getter 方法。vue 会收集计算属性的依赖，并缓存计算属性的返回结果。只有当依赖变化后才会重新进行计算。
  - 方法没有缓存，每次调用方法都会导致重新执行。
    计算属性的**getter 和 setter 参数固定，getter 没有参数，setter 只有一个参数**。而方法的参数不限。由于有以上的这些区别，因此计算属性通常是根据已有数据得到其他数据，并在得到数据的过程中不建议使用异步、当前时间、随机数等副作用操作。
- 实际上，他们最重要的区别是含义上的区别。**计算属性含义上也是一个数据，可以读取也可以赋值；方法含义上是一个操作，用于处理一些事情。**

- 完整的计算属性书写：

```js
computed:{
  get(){
    //getter
  },
  set(val){
    //setter
  }
}

//computed 计算的依赖项只有响应式数据!!!!
computed:{
  fullName(){
    get(){
      return this.firstName + ' ' + this.lastName + Date.now()//Date不是响应式数据,不会被追踪,所以不会触发fullName的重新计算
    }
  }
}
```

- 只包含 getter 的计算属性简写

```js
computed:{
  propName(参数自己决定){
    //getter
  }
}
```

| 特性     | computed（计算属性）                 | methods（方法）                |
| -------- | ------------------------------------ | ------------------------------ |
| 缓存     | ✅ 有缓存（依赖变化时才重新计算）    | ❌ 无缓存（每次调用都执行）    |
| 调用时机 | 被动（依赖变化时触发）               | 主动（显式调用时触发）         |
| 性能     | 更优（减少重复计算）                 | 相对较低（重复执行开销）       |
| 适用场景 | 依赖稳定的计算逻辑（如拼接、格式化） | 事件处理、每次需重新执行的逻辑 |

### 作用域样式对子组件根元素的影响

- App.vue 组件的作用域样式对子组件根元素的影响
  - 作用域样式会自动添加一个唯一的属性选择器（如 `[data-v-5811d9ee]`），确保样式只应用于当前组件实例的根元素。
  - 子组件的根元素也会自动添加相同的属性选择器，确保样式只应用于当前组件实例的根元素。
- **App 中配置全局样式,可以影响所有子组件的根元素**

### 命名规范

- 对子组件的根元素样式使用组件名称+container 方便区分和定位

### v-if 和 v-show 的区别

- v-if 能够控制是否生成 vnode，也就间接控制了是否生成对应的 dom。
  - 当 v-if 为 true 时，会生成对应的 vnode，并生成对应的 dom 元素；当其为 false 时，不会生成对应的 vnode，自然不会生成任何的 dom 元素。
- v-show 始终会生成 vnode，也就间接导致了始终生成 dom。
  - 它只是控制 dom 的 display 属性，当 v-show 为 true 时，不做任何处理；当其为 false 时，生成的 dom 的 display 属性为 none。
- 使用 v-if 可以有效的减少树的节点和渲染量，但也会导致树的不稳定；而使用 v-show 可以保持树的稳定，但不能减少树的节点和渲染量。
- 因此，在实际开发中，显示状态变化频繁的情况下应该使用 v-show，以保持树的稳定；显示状态变化较少时应该使用 v-if，以减少树的节点和渲染量。

### 组件事件(单向数据流)

<**子传父**>

- 抛出事件：子组件在某个时候发生了一件事，但自身无法处理，于是通过事件的方式通知父组件处理
- 事件参数：子组件抛出事件时，传递给父组件的数据
- 注册事件：父组件申明，当子组件发生某件事的时候，自身将做出一些处理

## 如何使用组件

- **编写组件说明文档**
  - 组件的功能、参数、事件、插槽等
- 组件的使用示例
  - 展示组件的基本用法和常见场景
- 组件的注意事项
  - 组件的依赖项、性能问题、浏览器兼容性等

## 如何测试单个组件

- 单独添加 test.vue 文件
  - 展示组件的基本用法和常见场景
- **官网推荐使用 vue-test-utils 库**
  - 提供了一组工具函数，用于测试 Vue 组件的行为和状态
  - 支持模拟事件、组件挂载、组件卸载等操作
  - 可以与其他测试工具（如**Jest**、Mocha 等）结合使用

### Menu 组件中如何判断某个菜单是否选中(取决于访问路径)

- 可以使用 `location.pathname` 来获取当前路由路径
- 如果相同，则说明该菜单是选中状态

### 组件的作用域样式

- :deep 可以深度选择子组件的根元素
- 可以使用 :deep 来选择子组件的根元素,并为其添加样式 不会影响到其他组件使用该组件

### 样式相关

- 给元素添加内边距，但又希望元素的总尺寸保持不变时，必须结合 box-sizing: border-box;。

```css
 {
  padding: 20px 0;
  box-sizing: border-box;
}
```

- **padding** 是为了增加元素的垂直内边距，而 **box-sizing: border-box**; 是为了确保内边距不会导致元素总尺寸 “膨胀”，从而保证布局的稳定性和可预测性。

### 方向对应规律

- CSS 多值属性的顺序，本质是对应「元素的四个方向」，优先级：**上下（垂直）> 左右（水平）**，或 **顺时针（上 → 右 → 下 → 左）**
  - 2 值写法（最常用）：[上下] [左右]
  - 3 值写法：[上] [左右] [下]
  - 4 值写法：[上] [右] [下] [左]

### 插槽(slot)使用

- 某些组件的模板中,部分区域需要父元素指定(因为其中的内容可以是任意的,比如图片 html 字符串...)
- 通过插槽来定制组件的功能

#### 具名插槽

- 如果某个组件中需要父元素传递多个区域的内容，也就意味着需要提供多个插槽
  为了避免冲突，就需要给不同的插槽赋予不同的名字

- 给插槽起个名字,父元素可以通过名字来指定插入的位置
- 没有指定名字的插槽,称为默认插槽

```vue
//子组件 Layout.vue
<slot name="header"></slot>
//父组件 传递内容
<Layout>
  <template v-slot:header>
    <h1>这是标题</h1>
  </template>
</Layout>
```

### 使用 vue-router

- 1.如何根据地址中的路径选择不同的组件？
- 3.如何无刷新的切换组件？
- 2.把选择的组件放到哪个位置？

#### hash 模式

适配浏览器不支持 history 模式的情况

#### history 模式

无刷新的切换组件 需要浏览器支持 history 模式

### 命名路由

- 使用命名路由可以**解除系统与路径之间的耦合**

```javascript
// 路由配置
const router = new VueRouter({
  routes: [
    // 路由规则
    // 当匹配到路径 /foo 时，渲染 Foo 组件
    { name: "foo", path: "/foo", component: Foo },
    // 当匹配到路径 /bar 时，渲染 Bar 组件
    { name: "bar", path: "/bar", component: Bar },
  ],
});
```

```html
<!-- 向to属性传递路由信息对象 RouterLink会根据你传递的信息以及路由配置生成对应的路径 -->
<RouterLink :to="{ name:'foo' }">go to foo</RouterLink>
```

## 实现消息通知(弹窗式)

### CSS Module 使用

- 开启 CSS Module 后，组件的样式将被限制在当前组件范围内，不会影响到其他组件
- 样式命名必须为 **xxx.module.css** 才能获取到(不然获取到的样式就是一个空对象)

```js
import styles from "./styles/message.module.less";
console.log(styles);
const div = document.createElement("div");
div.className = styles.message;
div.innerText = "asdfasdf";
document.body.appendchild(div);
```

### Vue 组件 → DOM 元素

```js
import { createApp, h, render } from "vue";

// 工具函数：获取组件的根 DOM 元素
function getComponentRootDom(comp, props) {
  // 1. 创建一个空的容器节点（用于挂载组件）
  const container = document.createElement("div");
  // 2. 手动创建组件的 VNode（虚拟节点）
  const vnode = h(comp, props);
  // 3. 将 VNode 渲染到容器中
  render(vnode, container);
  // 4. 返回渲染后的根 DOM 元素
  return container.firstElementChild;
}
// 调用示例（假设 Icon 是 Vue 3 组件）
import Icon from "./components/Icon.vue";
const dom = getComponentRootDom(Icon, { type: "home" });
console.log(dom); // 输出 Icon 组件渲染后的根 DOM 元素
```

#### 拓展 vue 实例

- 向 vue 实例添加方法 vue.prototype.xxx = function(){}

#### ref 操作 dom 元素

- **通过 ref 可以直接操作 dom 元素，甚至可能直接改动子组件，这些都不符合 vue 的设计理念**。(数据驱动视图 和 组件化的封装与解耦)
  三、Vue 3 与 Vue 2 的核心区别
  |场景 |Vue 2 写法| Vue 3 写法（组合式 API）|
  |----|----|----|
  |声明 |ref 无需声明,直接在模板中用 ref="xxx"，通过 this.$refs.xxx 访问	|需在 setup 中用 ref(null) 声明变量,模板中绑定 ref="xxx"，通过 xxx.value 访问|
|子组件访问|	直接通过 this.$refs.xxx 访问子组件实例所有属性方法| 子组件需用 defineExpose 显式暴露属性方法，父组件才能访问|

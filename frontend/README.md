# 知识总结

- scoped:带有作用域的样式,防止样式冲突
  - 例如:.avatar-img[data-v-5811d9ee](唯一标识)
- display: block; 行盒：与其他行盒在同一行排列

### 预编译

| **维度**     | **Vue 模板预编译**                                                            | **Vite 依赖预编译**                                                                                             |
| ------------ | ----------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| **技术范畴** | Vue 框架的**生产环境构建优化**，解决模板运行时编译开销问题。                  | Vite 构建工具的**开发环境体验优化**，解决第三方依赖加载效率与兼容性问题。                                       |
| **目标**     | 让 Vue 项目在生产环境**运行更快、体积更小**。                                 | 让项目在开发环境**启动更快、请求更少**，提升开发体验。                                                          |
| **发生阶段** | 项目**构建阶段**（如 `vue-cli` 打包时）。                                     | 开发环境**启动阶段**（运行 `vite` 命令后）。                                                                    |
| **处理对象** | Vue 组件的 `<template>` 模板 → 转换为 `render` 函数。                         | 第三方依赖模块（如 `lodash`、`react` 等）→ 转换模块格式、合并小模块。                                           |
| **依赖工具** | `vue-loader`、`@vue/compiler-sfc` 等 Vue 生态工具。                           | `esbuild`（Go 语言编写的极速构建工具）。                                                                        |
| **核心作用** | 1. 运行时无需编译模板，提升渲染性能；2. 移除 Vue 运行时编译器，减小打包体积。 | 1. 转换 CommonJS 依赖为 ES 模块，兼容浏览器；2. 合并小模块，减少浏览器请求数；3. 缓存预编译结果，加速后续启动。 |

### 计算属性和方法的区别

- 计算属性**本质上是包含 getter 和 setter**的方法
  - 当获取计算属性时，实际正是在调用计算属性的 getter 方法。vue 会收集计算属性的依赖，并缓存计算属性的返回结果。只有当依赖变化后才会重新进行计算。
  - 方法没有缓存，每次调用方法都会导致重新执行。
    计算属性的**getter 和 setter 参数固定，getter 没有参数，setter 只有一个参数**。而方法的参数不限。由于有以上的这些区别，因此计算属性通常是根据已有数据得到其他数据，并在得到数据的过程中不建议使用异步、当前时间、随机数等副作用操作。
- 实际上，他们最重要的区别是含义上的区别。**计算属性含义上也是一个数据，可以读取也可以赋值；方法含义上是一个操作，用于处理一些事情。**

- 完整的计算属性书写：

```js
computed:{
  get(){
    //getter
  },
  set(val){
    //setter
  }
}

//computed 计算的依赖项只有响应式数据!!!!
computed:{
  fullName(){
    get(){
      return this.firstName + ' ' + this.lastName + Date.now()//Date不是响应式数据,不会被追踪,所以不会触发fullName的重新计算
    }
  }
}
```

- 只包含 getter 的计算属性简写

```js
computed:{
  propName(参数自己决定){
    //getter
  }
}
```

| 特性     | computed（计算属性）                 | methods（方法）                |
| -------- | ------------------------------------ | ------------------------------ |
| 缓存     | ✅ 有缓存（依赖变化时才重新计算）    | ❌ 无缓存（每次调用都执行）    |
| 调用时机 | 被动（依赖变化时触发）               | 主动（显式调用时触发）         |
| 性能     | 更优（减少重复计算）                 | 相对较低（重复执行开销）       |
| 适用场景 | 依赖稳定的计算逻辑（如拼接、格式化） | 事件处理、每次需重新执行的逻辑 |

### 作用域样式对子组件根元素的影响

- App.vue 组件的作用域样式对子组件根元素的影响
  - 作用域样式会自动添加一个唯一的属性选择器（如 `[data-v-5811d9ee]`），确保样式只应用于当前组件实例的根元素。
  - 子组件的根元素也会自动添加相同的属性选择器，确保样式只应用于当前组件实例的根元素。
- **App 中配置全局样式,可以影响所有子组件的根元素**

### 命名规范
- 对子组件的根元素样式使用组件名称+container  方便区分和定位